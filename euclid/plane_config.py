#!/usr/bin/python3
"""
 * Copyright (c) 2020, The LightCo
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are strictly prohibited without prior permission of
 * The LightCo.
 *
 * @author  Chuck Stanski
 * @version V1.0.0
 * @date    June 2020
 * @brief
 *  PMA Plane configuration files
 *
"""
import argparse
import re
import datetime
import os
import numpy as np
from pma_types import *
from grid_map import *


"""
*********************************** MAIN ********************************
"""
parser = argparse.ArgumentParser(description="PMA Plane Configuration")
parser.add_argument('--out_basename', help="<Required> Output base filename")
parser.add_argument('--h_file', action='store_true', default=False, help="<Optional> Generates H file output")
parser.add_argument('--data_file', action='store_true', default=False, help="<Optional> Generate data file")
parser.add_argument('--read_file', action='store_true', default=False, help="<Optional> Read data file")
parser.add_argument('--P', nargs=2, type=int, help="<Required> Patch: Px Py")
parser.add_argument('--S', nargs=2, type=int, help="<Required> Step: Sx Sy")
parser.add_argument('--J', nargs=2, type=int, help="<Required> Jump: Jx Jy")
parser.add_argument('--a', nargs=3, type=float, help="<Optional> amin amax astep")
parser.add_argument('--b', nargs=3, type=float, help="<Optional> bmin bmax bstep")
parser.add_argument('--c', nargs=3, type=float, help="<Optional> cmin cmax cstep")
parser.add_argument('--drop_nd', action='store_true', default=False, help="Drop Non-Distorted Config")
parser.add_argument('--config_idx', type=int, help="<Required> Configuration Index [0..7]")
parser.add_argument('--patch_timing_sel', type=int, help="<Required> Patch timing select [0..1]")
parser.add_argument('--amend', action='store_true', default=False, help="Amends to existing data file")
parser.add_argument('--json', help="keep scripts consistent")
parser.add_argument('--test_name', help="keep scripts consistent")
parser.add_argument('--index', help="keep scripts consistent")

args, unknown = parser.parse_known_args()
if unknown:
    print("Unknown options: {}".format(unknown))

# Generate H file (if required)
if args.h_file:
    filename = args.out_basename + ".h"
    macro_name = re.sub("/", "_", args.out_basename.upper())
    macro_name = macro_name[1:]
    namespace_name = re.sub("\.h", "", os.path.basename(filename))
    outfile = open(filename, "wt")

    outfile.write("// AUTOGENERATED FILE - DO NOT EDIT!\n")
    outfile.write("\n")
    outfile.write("/*******************************************************************************\n")
    outfile.write(" * Copyright (c) 2020 Light Labs Inc.\n")
    outfile.write(" * All Rights Reserved\n")
    outfile.write(" * Proprietary and Confidential - Light Labs Inc. \n")
    outfile.write(" * Redistribution and use in source and binary forms, with or without\n")
    outfile.write(" * modification, are strictly prohibited without prior permission of\n")
    outfile.write(" * Light Labs Inc.\n")
    outfile.write(" *\n")
    outfile.write(" * @author  Light Labs Inc\n")
    outfile.write(" * @version V1.0.0\n")
    d = datetime.date.today()
    outfile.write(" * @date    {} {}, {}\n".format(d.strftime('%B'), d.day, d.year))
    outfile.write(" * @brief   \n")
    outfile.write(" *\n")
    outfile.write(" ******************************************************************************/\n")
    outfile.write("\n")
    outfile.write("#ifndef {}_\n".format(macro_name))
    outfile.write("#define {}_\n".format(macro_name))
    outfile.write("\n")
    outfile.write("#include <cstdint>\n\n")
    outfile.write("namespace {}\n".format(namespace_name))
    outfile.write("{\n")
    outfile.write("    struct {}\n".format("PLANE_CONFIGURATION_PARAMS_T".lower()))
    outfile.write("    {\n")
    for f in PLANE_CONFIGURATION_PARAMS_T._fields_:
        t, a = parse_type(f)
        outfile.write("        {} {}".format(t, f[0]))
        if a > 1:
            outfile.write("[{}]".format(a))
        outfile.write(";\n")
    outfile.write("    };\n")
    outfile.write("\n")
    outfile.write("    struct {}\n".format("PLANE_CONFIGURATION_COMMAND_T".lower()))
    outfile.write("    {\n")

    for f in PLANE_CONFIGURATION_COMMAND_T._fields_:
        t, a = parse_type(f)
        outfile.write("        {} {}".format(t, f[0]))
        if a > 1:
            outfile.write("[{}]".format(a))
        outfile.write(";\n")
    outfile.write("    };\n")

    outfile.write("}}  // namespace {}\n\n".format(namespace_name))
    outfile.write("#endif  // namespace {}_\n\n".format(macro_name))
    outfile.close()

if args.data_file:
    # Error checks
    if args.config_idx < 0 or args.config_idx > 7:
        print("--config_idx must be between 0 and 7")
        sys.exit(-1)

    if args.patch_timing_sel < 0 or args.patch_timing_sel > 1:
        print("--patch_timing_sel must be between 0 and 1")
        sys.exit(-1)

    pma = []
    P = [args.P[0], args.P[1]]
    S = [args.S[0], args.S[1]]
    J = [args.J[0], args.J[1]]

    drop_nd = args.drop_nd

    if args.a is not None:
        scale_min = args.a[0] * (P[0] - 1) / 2
        scale_max = args.a[1] * (P[0] - 1) / 2
        scale_step = args.a[2]

        if scale_step == 0:
            print("astep cannot be 0")
            sys.exit(-1)

        for scale in np.arange(scale_min, scale_max + scale_step / 2, scale_step):
            if drop_nd and scale == 0.0:
                continue

            if scale == 0.0:
                drop_nd = True

            d, gg_map, C, d0, _, d_shift, _, align_err = compute_gg_map(
                P[0], P[1],
                S[0], S[1],
                J[0], J[1],
                compute_ab(P[0], scale),
                compute_ab(P[0], 0),
                0)

            pma.append(dict())
            pma[-1]['d'] = d
            pma[-1]['gg_map'] = gg_map
            pma[-1]['C'] = C
            pma[-1]['d_shift'] = d_shift
            pma[-1]['offset'] = 0

    if args.b is not None:
        shear_min = args.b[0] * (P[0] - 1) / 2
        shear_max = args.b[1] * (P[0] - 1) / 2
        shear_step = args.b[2]

        if shear_step == 0:
            print("bstep cannot be 0")
            sys.exit(-1)

        for shear in np.arange(shear_min, shear_max + shear_step / 2, shear_step):
            if drop_nd and shear == 0.0:
                continue

            if shear == 0.0:
                drop_nd = True

            d, gg_map, C, d0, _, d_shift, _, align_err = compute_gg_map(
                P[0], P[1],
                S[0], S[1],
                J[0], J[1],
                compute_ab(P[0], 0),
                compute_ab(P[0], shear),
                0)

            pma.append(dict())
            pma[-1]['d'] = d
            pma[-1]['gg_map'] = gg_map
            pma[-1]['C'] = C
            pma[-1]['d_shift'] = d_shift
            pma[-1]['offset'] = 0

    if args.c is not None:
        offset_min = args.c[0] * 4
        offset_max = args.c[1] * 4
        offset_step = args.c[2] * 4

        if offset_step == 0:
            print("cstep cannot be 0")
            sys.exit(-1)

        for offset in np.arange(offset_min, offset_max + offset_step / 2, offset_step):
            if drop_nd and offset == 0.0:
                continue

            if offset == 0.0:
                drop_nd = True

            d, gg_map, C, d0, _, d_shift, _, align_err = compute_gg_map(
                P[0], P[1],
                S[0], S[1],
                J[0], J[1],
                compute_ab(P[0], 0),
                compute_ab(P[0], 0),
                offset)

            pma.append(dict())
            pma[-1]['d'] = d
            pma[-1]['gg_map'] = gg_map
            pma[-1]['C'] = C
            pma[-1]['d_shift'] = d_shift
            pma[-1]['offset'] = offset

    # Find the max Cx and use for all planes
    Cx_max = 0
    for p in pma:
        if p['C']['Cx'] > Cx_max:
            Cx_max = p['C']['Cx']

    # Generate data file to push to FW
    if args.amend:
        # Read existing file
        filename = args.out_basename + "_" + str(args.config_idx) + ".dat"
        infile = open(filename, "rb")
        plane_command = unpack(PLANE_CONFIGURATION_COMMAND_T, infile.read())
        infile.close()
        plane_start_idx = plane_command.num_planes
        plane_command.num_planes += len(pma)
    else:
        plane_command = PLANE_CONFIGURATION_COMMAND_T()
        plane_command.config_idx = args.config_idx
        plane_command.num_planes = len(pma)
        plane_command.ref_patch_offset_q2 = int(d0[2] * 4)
        plane_start_idx = 0
    plane_command.n_xy[args.patch_timing_sel] = np.sum(pma[0]['gg_map']).astype(np.uint16)

    if (plane_start_idx + len(pma)) > MAX_NUM_PLANES:
        print("plane_start_idx + len(pma) exceeds the maximum number of planes")
        print("plane_start_idx: {}, len(pma): {}, MAX_NUM_PLANES: {}".format(plane_start_idx, len(pma), MAX_NUM_PLANES))
        sys.exit(-1)

    for idx in range(len(pma)):
        plane_idx = plane_start_idx + idx
        plane_command.params[plane_idx].a = int(pma[idx]['d'][0] * 256)
        plane_command.params[plane_idx].b = int(pma[idx]['d'][1] * 256)
        plane_command.params[plane_idx].c = int(pma[idx]['d'][2] * 4)
        plane_command.params[plane_idx].patch_timing_sel = args.patch_timing_sel
        plane_command.params[plane_idx].offset = int(pma[idx]['offset'])
        n_xy = np.sum(pma[idx]['gg_map']).astype(np.uint16)
        if n_xy != plane_command.n_xy[args.patch_timing_sel]:
            print("Inconsistent Nxy values across planes")
            sys.exit(-1)
        for map_idx in range(len(pma[idx]['C']['gg_map_ulong'])):
            plane_command.params[plane_idx].gg_map[2*map_idx] = pma[idx]['C']['gg_map_ulong'][map_idx]
            plane_command.params[plane_idx].gg_map[2*map_idx+1] = int(pma[idx]['C']['gg_map_ulong'][map_idx] / 2**32)
        if pma[idx]['d_shift'].shape[0] != 1:
            plane_command.params[plane_idx].disparity_shift_dim = 1
        else:
            plane_command.params[plane_idx].disparity_shift_dim = 0
        d_shift = np.squeeze(pma[idx]['d_shift'])
        for d_shift_idx in range(d_shift.size):
            plane_command.params[plane_idx].d_shift[d_shift_idx] = d_shift[d_shift_idx]

    filename = args.out_basename + "_" + str(args.config_idx) + ".dat"
    outfile = open(filename, "wb")
    outfile.write(pack(plane_command))
    outfile.close()

if args.read_file:
    filename = args.out_basename + "_" + str(args.config_idx) + ".dat"
    infile = open(filename, "rb")
    log_plane_config(infile.read())
    infile.close()


